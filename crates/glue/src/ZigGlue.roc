app "zig-glue"
    packages { pf: "../platform/main.roc" }
    imports [
        pf.Types.{ Types },
        pf.File.{ File },
        pf.Shape.{ Shape },
    ]
    provides [makeGlue] to pf

makeGlue : List Types -> Result (List File) Str
makeGlue = \typesByArch ->
    typesByArch
    |> List.map convertTypesToFile
    |> Ok

convertTypesToFile : Types -> File
convertTypesToFile = \types ->
    parts =
        Types.walkShapes types [] \state, type, id ->
            when type is
                Struct { name, fields } ->
                    addStruct state types name fields

                RocStr ->
                    List.append
                        state
                        "pub const RocStr = glue.str.RocStr;"

                TagUnion (Enumeration { name, tags }) ->
                    zigTags =
                        List.map
                            tags
                            (\tag ->
                                tag
                                |> toLower
                                |> Str.concat ",\n"
                            )
                        |> Str.joinWith ""

                    enum =
                        """
                        pub const \(name) = enum(c_int){
                            \(zigTags)
                        };
                        """
                    List.append state enum

                TagUnion (NonRecursive { name: tagName, tags }) ->
                    zigTags =
                        List.map
                            tags
                            (\{ name, payload: payload } ->
                                payloadtype =
                                    when payload is
                                        Some payloadTypeID ->
                                            typeName types payloadTypeID

                                        None -> "void"

                                "\(name |> toLower): \(payloadtype),\n"
                            )
                        |> Str.joinWith ""

                    enum =
                        """
                        pub const \(tagName) = enum(c_int){
                            \(zigTags)
                        };
                        """
                    List.append state enum

                Num Dec ->
                    List.append
                        state
                        "pub const RocDec = glue.dec.RocDec;"

                Unsized
                | Unit
                | Num _
                | Bool
                | RocDict _ _
                | RocResult _ _
                | RocSet _
                | RocList _
                | RocBox _ -> state

                _ ->
                    List.append state "TODO \(typeName types id)"

    content = Str.concat fileHeader (Str.joinWith parts "\n\n")

    {
        name: "glue.zig",
        content: content,
    }

fileHeader =
    """
    // ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

    const glue = @import("glue");

    pub fn RocResult(comptime T: type, comptime E: type) type {
        return extern struct {
            payload: RocResultPayload(T, E),
            tag: RocResultTag,
        };
    }

    pub fn RocResultPayload(comptime T: type, comptime E: type) type {
        return extern union {
            ok: T,
            err: E,
        };
    }

    const RocResultTag = enum(u8) {
        RocErr = 0,
        RocOk = 1,
    };

    """

toLower : Str -> Str
toLower = \str ->
    # TODO: This does only work for ascii
    str
    |> Str.toUtf8
    |> List.map \c ->
        if c >= 'A' && c <= 'Z' then
            c - 'A' + 'a'
        else
            c
    |> Str.fromUtf8
    |> Result.withDefault "non ascii not supported"

addStruct : List Str, Types, Str, Shape.RocStructFields -> List Str
addStruct = \list, types, structName, outFields ->
    when outFields is
        HasNoClosure fields ->
            zigFields =
                List.map
                    fields
                    (\{ name, id } ->
                        type = typeName types id
                        "\(name): \(type),\n"
                    )
                |> Str.joinWith ""

            List.append
                list
                """
                pub const \(structName) = extern struct {
                    \(zigFields)
                };
                """

        _ -> list

typeName = \types, id ->
    when Types.shape types id is
        Unit -> "()"
        Unsized -> "roc_std::RocList<u8>"
        EmptyTagUnion -> "std::convert::Infallible"
        RocStr -> "*RocStr"
        Bool -> "bool"
        Num U8 -> "u8"
        Num U16 -> "u16"
        Num U32 -> "u32"
        Num U64 -> "u64"
        Num U128 -> "u128"
        Num I8 -> "i8"
        Num I16 -> "i16"
        Num I32 -> "i32"
        Num I64 -> "i64"
        Num I128 -> "i128"
        Num F32 -> "f32"
        Num F64 -> "f64"
        Num Dec -> "RocDec"
        RocDict key value ->
            keyName = typeName types key
            valueName = typeName types value

            "roc_std::RocDict<\(keyName), \(valueName)>"

        RocSet elem ->
            elemName = typeName types elem

            "roc_std::RocSet<\(elemName)>"

        RocList elem ->
            elemName = typeName types elem

            "[]\(elemName)"

        RocBox elem ->
            elemName = typeName types elem

            "roc_std::RocBox<\(elemName)>"

        RocResult ok err ->
            okName = typeName types ok
            errName = typeName types err

            "RocResult(\(okName), \(errName))"

        RecursivePointer content ->
            typeName types content

        Struct { name } -> name
        TagUnionPayload { name } -> name
        TagUnion (NonRecursive { name }) -> name
        TagUnion (Recursive { name }) -> name
        TagUnion (Enumeration { name }) -> name
        TagUnion (NullableWrapped { name }) -> name
        TagUnion (NullableUnwrapped { name }) -> name
        TagUnion (NonNullableUnwrapped { name }) -> name
        TagUnion (SingleTagStruct { name }) -> name
        Function { functionName } -> functionName
